@startuml
skinparam classAttributeIconSize 0


'Items --------------------------------------------
abstract class Item {
    + use()
    + onPickup(Actor actor)
    + onDrop(Room room)
}

class Sponge {}

class Tvsz {}

class SlideRule {}

class Beer {}

class Cocktail {}

class GasMask {}

class Transistor {
    - pair: Transistor
    - location: IHasLocation
}

class Camembert {}

Item <|-- Sponge
Item <|-- Tvsz
Item <|-- SlideRule
Item <|-- Beer
Item <|-- Cocktail
Item <|-- GasMask
Item <|-- Transistor
Item <|-- Camembert

'Inventory ----------------------------------------
class Inventory {
    - size : int

    - isFull(): boolean
    + addItem(Item item): boolean
    + removeItem(Item item): Item
    + deleteItem(Item item): void
    + dropAll(Room target): void
    + getSize() : int
}

/' 
itt a remove és a delete összevonható lenne egy 
removeItem(Item item, boolean shouldDelete)-re
'/

Inventory "1" -- "0..*" Item

' azért asszociáció, mivel ettől még az item-nek van egyedi léte

Actor o-- Inventory
Room o-- Inventory

'Character ----------------------------------------

class Actor {
    - alive : boolean
    - location : Room
    - ActionStrategy : ActionStrategy
    - defenseStrategy : DefenseStrategy

    + tick() : void
    + {abstract} attacked() : void

    + addEffect(RoomEffect effect) : void
    + setActionStrategy(ActionStrategy TimeEffected) : void
    + setDefenseStrategy(DefenseStrategy TimeEffected) : void

    + isAlive() : boolean
    + {abstract} revive() : boolean
    + dropAllTo(Room room) : void
}

interface IActions {
    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
}

IActions <|.. Actor
IActions <|.. ActionStrategy

Actor "1" -- "1..*" ActionStrategy
Actor "1" -- "1..*" DefenseStrategy

class Student {
    + attacked() : void
    + revive() : boolean
    + attack() : void
}

class Professor {
    + attacked() : void
    + revive() : boolean
    + attack() : void
}

Actor <|-- Student
Actor <|-- Professor

'ez egy kísérleti dolog - szedd ki, ha nem tetszik

'Room ---------------------------------------------

class Room {
    - capacity : int
    - effects : RoomEffect[]

    + split() : void
    + merge(Room room) : void
    + attack(Professor attacker)
    
    - isFull() : boolean
    + enter(Actor actor) : boolean
    + leave(Actor actor) : void

    + addItem(Item item) : void
    + removeItem(Item item) : Item
    + dropAllTo(Room room) : void

    + tick() : void
}

/'
az egyirányú ajtók merge-nél eltűnnek, ha a két szoba 
között voltak?
ezt elég később lekezelni, de erre nem gondoltam még
'/

/' 
hogyan is fogjuk értesíteni a bennlévő professort, ha 
egy hallgató belép?

lehet ez egy merész gondolat, de mi lenne, ha mi az ajtót
kérnénk, hogy engedjen át minket?

és akkor a szoba enter-je tudna értesíteni minden bennlévőt
a belépésről
'/

class Door {
    - remainingInvisibility : int
    - isOneway : boolean
    - rooms : Room[]

    + hide(int duration) : void
    + leadsTo(Room from) : Room
    + move(Actor actor, Room target) : boolean
    + tick() : void
}

Room "1" -- "0..*" Actor 
Room "2" -- "1..*" Door
Room "1" -- "0..*" RoomEffect

interface IHasLocation {
    + getLocation(): Room
}

IHasLocation <|.. Room
IHasLocation <|.. Actor

'Effect -------------------------------------------
abstract class RoomEffect {
    - timeLeft : int
    + tick(): boolean
    + addEffect(Actor actor) : void
    + {abstract} applyEffect(Professor professor) : void
    + {abstract} applyEffect(Student student) : void
}
' tick returns false when the effect expires

RoomEffect <|-- WetEffect
RoomEffect <|-- GasEffect

class WetEffect {
    + applyEffect(Professor professor) : void
    + applyEffect(Student student) : void
}

class GasEffect {
    + applyEffect(Professor professor) : void
    + applyEffect(Student student) : void
}

abstract class TimeEffected {
    - timeLeft : int
    + tick() : void
}

abstract class ActionStrategy {
    - previous : ActionStrategy
    + step() : void
}

class DefaultStep {
    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
}
DefaultProfStep --|> DefaultStep
class DefaultProfStep {
    +move(Door door): boolean
    +attack(): void
}
class StunnedStep {
    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
}
TimeEffected <|-- ActionStrategy
ActionStrategy <|-- DefaultStep
ActionStrategy <|-- StunnedStep

abstract class DefenseStrategy {
    - previous : DefenseStrategy
    + defend(Professor attacker) : void
}

class DefaultDefense {}
class BeerDefense {}
TimeEffected <|-- DefenseStrategy
DefenseStrategy <|-- DefaultDefense
DefenseStrategy <|-- BeerDefense

'Visitors ----------------------------------------
interface ItemVisitor {
    + visit(Sponge sponge) : void
    + visit(Tvsz tvsz) : void
    + visit(SlideRule slideRule) : void
    + visit(Beer beer) : void
    + visit(Cocktail cocktail) : void
    + visit(GasMask gasMask) : void
    + visit(Transistor transistor) : void
    + visit(Camembert camembert) : void
}

@enduml