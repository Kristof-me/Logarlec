@startuml
skinparam classAttributeIconSize 0


'Items --------------------------------------------
abstract class Item {
    - usesLeft : int
    + use(invoker: Actor): void
    + getUsesLeft() : int
    + onPickup(Actor actor)
    + onDrop(Room room)
    + accept(ItemVisitor visitor)
}

class Sponge {
    + use(invoker: Actor): void
}

class Tvsz {
    + use(invoker: Actor): void
}

class SlideRule {
    + onPickup(Actor actor)
}

class Beer {
    + use(invoker: Actor): void
}

class Cocktail {
    + use(invoker: Actor): void
}

class GasMask {
    + use(invoker: Actor): void
}

class Transistor {
    - pair: Transistor
    - location: IHasLocation
    + use(invoker: Actor): void
}

class Camembert {
    + use(invoker: Actor): void
}

Item <|-- Sponge
Item <|-- Tvsz
Item <|-- SlideRule
Item <|-- Beer
Item <|-- Cocktail
Item <|-- GasMask
Item <|-- Transistor
Item <|-- Camembert

'Inventory ----------------------------------------
class Inventory {
    - size : int

    - isFull(): boolean
    + addItem(Item item): boolean
    + removeItem(Item item): Item
    + acceptVisitor(ItemVisitor visitor): void
    + deleteItem(Item item): void
    + dropAll(Room target): void
    + getSize() : int
}

/' 
itt a remove és a delete összevonható lenne egy 
removeItem(Item item, boolean shouldDelete)-re
'/

Inventory "1" -- "0..*" Item

' azért asszociáció, mivel ettől még az item-nek van egyedi léte

Actor *--"1" Inventory
Room o-- Inventory

'Character ----------------------------------------

class Actor {
    - alive : boolean
    - location : Room
    - defenseStrategy : DefenseStrategy

    + {abstract} attacked() : void
    + {abstract} revive() : boolean
    + {abstract} acceptEffect(RoomEffect effect, List<ItemFinder> unless) : void

    + setActionState(ActionState state) : void
    + setDefaultActionState() : void
    + setDefenseStrategy(DefenseStrategy defenseStrategy) : void

    + dropAllTo(Room room) : void
    + tick() : void

    + getInventory() : Inventory
}

Actor "1" -- "1" ActionState
Actor "1" -- "1..*" DefenseStrategy

class Student {
    + acceptEffect(RoomEffect effect, List<ItemFinder> unless) : void
    + attacked() : void
    + revive() : boolean
    + setDefaultActionState() : void
}

Actor <|-- Student

class Professor {
    + acceptEffect(RoomEffect effect, List<ItemFinder> unless) : void
    + attacked() : void
    + revive() : boolean
    + setDefaultActionState() : void
}

Actor <|-- Professor

'ez egy kísérleti dolog - szedd ki, ha nem tetszik

'Room ---------------------------------------------

class Room {
    - capacity : int
    - effects : RoomEffect[]

    + split() : void
    + merge(Room room) : void
    + attack(Professor attacker)
    
    - isFull() : boolean
    + enter(Actor actor) : boolean
    + leave(Actor actor) : void
    + revive(): boolean

    + addItem(Item item) : void
    + removeItem(Item item) : Item
    + dropAllTo(Room room) : void

    + addEffect(RoomEffect effect) : void

    + tick() : void
}

/'
az egyirányú ajtók merge-nél eltűnnek, ha a két szoba 
között voltak?
ezt elég később lekezelni, de erre nem gondoltam még
'/

/' 
hogyan is fogjuk értesíteni a bennlévő professort, ha 
egy hallgató belép?

lehet ez egy merész gondolat, de mi lenne, ha mi az ajtót
kérnénk, hogy engedjen át minket?

és akkor a szoba enter-je tudna értesíteni minden bennlévőt
a belépésről
'/

class Door {
    - remainingInvisibility : int
    - isOneway : boolean
    - rooms : Room[]

    + hide(int duration) : void
    + leadsTo(Room from) : Room
    + move(Actor actor, Room target) : boolean
    + tick() : void
}

Room "1" -- "0..*" Actor 
Room "2" -- "1..*" Door
Room "1" -- "0..*" RoomEffect

interface IHasLocation {
    + getLocation(): Room
}

IHasLocation <|.. Room
IHasLocation <|.. Actor

'Effect -------------------------------------------
abstract class RoomEffect {
    - timeLeft : int
    - unlessHas : List<ItemFinder>
    + tick(): boolean
    + addEffect(Actor actor, List<ItemFinder> unlessHas) : void
    + {abstract} applyEffect(Professor professor) : void
    + {abstract} applyEffect(Student student) : void
}
' tick returns false when the effect expires

RoomEffect <|-- WetEffect
RoomEffect <|-- GasEffect

class WetEffect {
    + applyEffect(Professor professor) : void
    + applyEffect(Student student) : void
}

class GasEffect {
    + applyEffect(Professor professor) : void
    + applyEffect(Student student) : void
}

'State --------------------------------------------
interface IActions {
    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
}

IActions <|.. Actor
IActions <|.. ActionState

abstract class ActionState {
    - actor : Actor
    - inventory : Inventory
    - room : Room
    + tick() : void
}

class StudentActions {
    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
}

StudentActions --|> ActionState

class ProfessorActions {
    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
}

ProfessorActions --|> ActionState

class StunnedStep {
    - remainingTime : int

    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
    + tick() : void
}

StunnedStep --|> ActionState

'Strategy -----------------------------------
abstract class DefenseStrategy {
    + defend(inventory: Inventory) : void
}

class DefaultDefense {
    + defend(inventory: Inventory) : void
}

class BeerDefense {
    - remaining : int
    + defend(inventory: Inventory) : void
    + tick() : void
}

DefenseStrategy <|-- DefaultDefense
DefenseStrategy <|-- BeerDefense

'Visitors ----------------------------------------
abstract class ItemVisitor {
    + visit(Sponge sponge) : void
    + visit(Tvsz tvsz) : void
    + visit(SlideRule slideRule) : void
    + visit(Beer beer) : void
    + visit(Cocktail cocktail) : void
    + visit(GasMask gasMask) : void
    + visit(Transistor transistor) : void
    + visit(Camembert camembert) : void
}

ItemVisitor ..> Item

abstract class ItemFinder {
    # potentialItems : Items[]
    + findIn(Inventory inventory): Item
}

ItemFinder --|> ItemVisitor

class TransistorPairFinder {
    + visit(Transistor transistor) : void
}

class BestGasMaskFinder {
    + visit(GasMask gasMask) : void
}

class BestTvszFinder {
    + visit(GasMask gasMask) : void
}   

ItemFinder <|-- TransistorPairFinder
ItemFinder <|-- BestGasMaskFinder
ItemFinder <|-- BestTvszFinder

@enduml