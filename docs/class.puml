@startuml classDiagram
skinparam classAttributeIconSize 0

'Items --------------------------------------------
abstract class Item {
    - usesLeft : int
    + use(invoker: Actor): void
    + getUsesLeft() : int
    + onPickup(actor: Actor): void
    + onDrop(room: Room): void
    + accept(visitor: ItemVisitor): void
}

class Sponge {
    + use(invoker: Actor): void
}

class Tvsz {
    + use(invoker: Actor): void
}

class SlideRule {
    + onPickup(actor: Actor)
}

class Beer {
    + use(invoker: Actor): void
}

class Cocktail {
    + use(invoker: Actor): void
}

class GasMask {
    + use(invoker: Actor): void
}

class Transistor {
    - pair: Transistor
    - location: IHasLocation
    + use(invoker: Actor): void
    + pairWith(pair : Transistor) : void
    + onDrop(room: Room) : void
}

class Camembert {
    + use(invoker: Actor): void
}

Item <|-- Sponge
Item <|-- Tvsz
Item <|-- SlideRule
Item <|-- Beer
Item <|-- Cocktail
Item <|-- GasMask
Item <|-- Transistor
Item <|-- Camembert

'Inventory ----------------------------------------
class Inventory {
    - size : int

    - isFull(): boolean
    + addItem(item: Item): boolean
    + removeItem(item: Item): Item
    + acceptVisitor(visitor: ItemVisitor): void
    + deleteItem(item: Item): void
    + dropAll(target: Room): void
    + getSize() : int
}

/' 
itt a remove és a delete összevonható lenne egy 
removeItem(Item item, boolean shouldDelete)-re
'/

Inventory "1" -- "0..*" Item

' azért asszociáció, mivel ettől még az item-nek van egyedi léte

Actor *--"1" Inventory
Room *-- "1" Inventory

'Character ----------------------------------------

abstract class Actor {
    - alive : boolean
    - location : Room

    + {abstract} attacked() : void
    + {abstract} revive() : boolean
    + {abstract} acceptEffect(RoomEffect effect, List<ItemFinder> unless) : void

    + {abstract}setDefaultActionState() : void
    + setActionState(state: ActionState) : void
    + setDefenseStrategy(defenseStrategy: DefenseStrategy) : void

    + teleport(room: Room, isForced: boolean) : boolean
    + dropAllTo(room: Room) : void
    + tick() : void

    + getInventory() : Inventory
}

Actor -- "1" ActionState
Actor -- "1" DefenseStrategy

class Student {
}

Actor <|-- Student

class Professor {
}

Actor <|-- Professor

'ez egy kísérleti dolog - szedd ki, ha nem tetszik

'Room ---------------------------------------------

class Room {
    - capacity : int
    - effects : RoomEffect[]

    + split() : void
    + merge(room: Room) : void
    + attack(attacker: Professor)
    
    - isFull() : boolean
    + enter(actor: Actor) : boolean
    + leave(actor: Actor) : void
    + revive(): boolean

    + addItem(item: Item) : void
    + removeItem(item: Item) : Item

    + addEffect(effect: RoomEffect) : void

    + tick() : void
}

/'
az egyirányú ajtók merge-nél eltűnnek, ha a két szoba 
között voltak?
'/

/' 
hogyan is fogjuk értesíteni a bennlévő professort, ha 
egy hallgató belép?
'/

class Door {
    - remainingInvisibility : int
    - isOneway : boolean
    - rooms : Room[]

    + hide(duration: int) : void
    + leadsTo(from: Room) : Room
    + move(actor: Actor, target: Room) : boolean
    + tick() : void
}

Room "1" -- "0..*" Actor 
Room "2" -- "1..*" Door
Room "1" -- "0..*" RoomEffect

interface IHasLocation {
    + getLocation(): Room
}

IHasLocation <|.. Room
IHasLocation <|.. Actor

'Effect -------------------------------------------
abstract class RoomEffect {
    - timeLeft : int
    - unlessHas : List<ItemFinder>
    + tick(): boolean
    + addEffect(Actor actor) : void
    + {abstract} applyEffect(professor: Professor) : void
    + {abstract} applyEffect(student: Student) : void
}
' tick returns false when the effect expires

RoomEffect <|-- WetEffect
RoomEffect <|-- GasEffect

class WetEffect {
}

class GasEffect {
}

'State --------------------------------------------
interface IActions {
    + attack() : void
    + move(Door door) : boolean
    + use(Item item) : void
    + pickUp(Item item) : boolean
    + drop(Item item) : void
}

IActions <|.. Actor
IActions <|.. ActionState

abstract class ActionState {
    - actor : Actor
    - inventory : Inventory
    - room : Room
    + tick() : void
    + attack() : void
    + move(door: Door) : boolean
    + use(item: Item) : void
    + pickUp(item: Item) : boolean
    + drop(item: Item) : void
}

class StudentActions {
    + attack() : void
    + move(door: Door) : boolean
    + pickUp(item: Item) : boolean
}

StudentActions --|> ActionState

class ProfessorActions {
    + attack() : void
    + move(door: Door) : boolean
    + pickUp(item: Item) : boolean
}

ProfessorActions --|> ActionState

class StunnedStep {
    - remainingTime : int

    + attack() : void
    + move(door: Door) : boolean
    + use(item: Item) : void
    + pickUp(item: Item) : boolean
    + drop(item: Item) : void
    + tick() : void
}

StunnedStep --|> ActionState

'Strategy -----------------------------------
abstract class DefenseStrategy {
    + defend(inventory: Inventory) : void
}

class DefaultDefense {
    + defend(inventory: Inventory) : void
}

class BeerDefense {
    - remaining : int
    + defend(inventory: Inventory) : void
    + tick() : void
}

DefenseStrategy <|-- DefaultDefense
DefenseStrategy <|-- BeerDefense

'Visitors ----------------------------------------
abstract class ItemVisitor {
    + visit(sponge: Sponge) : void
    + visit(tvsz: Tvsz) : void
    + visit(slideRule: SlideRule) : void
    + visit(beer: Beer) : void
    + visit(cocktail: Cocktail) : void
    + visit(gasMask: GasMask) : void
    + visit(transistor: Transistor) : void
    + visit(camembert: Camembert) : void
}

ItemVisitor ..> Item

abstract class ItemFinder<T extends Item> {
    # potentialItems : List<T>
    + findIn(inventory: Inventory): T
}

ItemFinder --|> ItemVisitor

class TransistorPairFinder {
    + visit(transistor: Transistor) : void
}

class BestGasMaskFinder {
    + visit(gasMask: GasMask) : void
}

class BestTvszFinder {
    + visit(tvsz: Tvsz) : void
}   

ItemFinder <|-- TransistorPairFinder
ItemFinder <|-- BestGasMaskFinder
ItemFinder <|-- BestTvszFinder

@enduml